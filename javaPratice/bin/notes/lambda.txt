-- lambda expression: is an implementation of interface having only one abstract method (called Functional Interface). So its basically the body of only abstract method of an interface.

-- Function as first class object: ability to assign a function to a variable- having a reference of function.
   Ex: GreetMe g= (n) -> n.toUpperCase();  where GreetMe is an interface with one abstract method 

-- Higher Order Function: a function which receives another behaviour/function as parameter.
   Normal function has behaviour/implementation. It gets data and processes data based on that behaviour/implementation
Higher Order Function has data and it should receive behaviour/implementation that has to be implemented on that data.

-- Java 8 provide 4 Functional Interfaces which can be used for writing lambda expression. (Runnable and Callable are also there but not used much)
   1. Supplier<T>: no input, return T, method is: get(), lambda chaining: N/A, Bi-Type: N/A
   Ex: Supplier<Double> random= () -> Math.random();
       Systemout.println(random.get());

   2. Consumer<T>: T input, void return, method is: accept() , lambda chaining: andThen(Consumer<T>), Bi-Type: BiConsumer<T,R>
   Ex: Consumer<String> pp= (s) -> System.out::println;
       pp.accept("Saurabh");

       List<String> l= new ArrayList<>();
       l.forEach(l); //this will print all entry of list

   3. Predicate<T>: T input, boolean return, method is: test() , lambda chaining: and(Predicate<T>)/or(Predicate<T>)/negate, Bi-Type: BiPredicate<T,R>
   Ex: Predicate<Integer> gretaerThan2= (n) -> n>2;
       Predicate<Integer> lessThan10= (n) -> n<10;
       System.out.println(gretaerThan2.and(lessThan10).test(5));

   4. Function<T, R>: T input, R return, method is: apply() , lambda chaining: andThen(Function)/compose(Function), Bi-Type: BiFunction<T,U,R>
   Ex: Function<String, Integer> length= (s) -> s.length();
       Function<Integer, Integer> square= (n) -> n*n;
       System.out.println(length.andThen(square).apply("Saurabh"));
       Note: The second Function is expecting Integer input. So while chaining, first Function should return Integer else complie error while chaining.
       Note: Function1.andThen(Function2): here first Function1 is executed and then Function2.
             Function2.compose(Function2): here first Function2 is executed and then Function1.

-- Lambda chaining is the process of joining two or more lambdas together. They should be of same type. Like Consumer<String> and Consumer<String> can be  chained but Consumer<String> and Consumer<Integer> cannot be chained.
   Ex: List<String> l= new ArrayList<>();
       Consumer<String> pp1= (s) -> System.out::println;
       Consumer<String> pp2= (s) -> System.out.println(s.toUpperCase());
       Consumer<String> pp= pp1.andThen(pp2);
       l.forEach(pp);

-- Bi-Type means lambdas accepting two parameters.
   Ex: BiConsumer<String, Integer> pp1= (s, i) -> System.out.println(s+i);
       BiConsumer<String, Integer> pp2= (s, i) -> System.out.println(s+"-"+i);
       BiConsumer<String, Integer> pp= pp1.andThen(pp2);
       pp.accept("Saurabh", 938);


-- List methods that can be used:
   forEach()-- iterates on each element and performs action based on Consumer<T> parameter
   removeIf()-- iterates on each element and performs action based on Predicate<T> parameter

-- Difference between andThen(Consumer) and andThen(Function)
   Consumer1.andThen(Consumer2);-- here whatever input is received by Consumer1 is the same input received by Consumer2
   Function1.andThen(Function2);-- here whatever output is generated by Function1 is received as input by Function2 Consumer2


   
       