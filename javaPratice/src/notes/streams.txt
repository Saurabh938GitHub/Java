-- A stream represents a sequence of elements. It is not a data structure. It does not store data on which it is applied. Streams can be used with List, Set, Map, etc.

-- Note: when list is empty, then streams operations will not get performed and also no exception would be thrown.

-- Java stream operation can be Intermediate or Terminal.
   Intermediate: returns new stream.
   Terminal: stream is consumed and cannot be reused.

-- Intermediate Operations:
   1. filter(): used for filtering data. Input is Predicate<T>
      Ex: filter(i -> i%2==0)
   2. map(): transforms the data. Input is Function<T, R>
      Ex: map(i -> i*i)
   3. limit(): to limit the number of data. Input is long
      Ex: limit(3)
   4. skip(): skips the mentioned data from start. Input is long
      Ex: skip(3)
   5. peek(): just for debugging. Input is Consumer<T>
      Ex: peek(i -> System.out.println(i))
   6. distinct(): allows only distinct value. No Input
      Ex: distinct()
   7. sorted(): sorts the data (ascending/descending). Input is Comparator
      Ex: sorted(Comparator.naturalOrder()/Comparator.reverseOrder())
      Note: sorted() position is important. All previous operations has to be completed and that data set is given for sorting. So place this method correctly.
      Ex: list.stream().filter().limit().map().forEach()-- here list data will come one by one and all operation will be performed till forEach()
Ex: list.stream().filter().limit().sorted().map().forEach()-- here list data will come one by one till limit()... whole data set will be then sorted.. and then one by one data from sorted list will got to map() and forEach()
   8. flatMap(): falttens the data. Input is Function<T, R>


-- Terminal Operations:
   1. forEach(): used for consuming each object. Input is Consumer<T>
      Ex: forEach(i -> i.click())
   2. collect(): to collect object into list, set, map, etc.
      Ex: collect(Collectors.toList()/Collectors.toSet())
   3. count(): to lcount the object. No Input
      Ex: count()
   4. min(): first element after compairing all. Input is Comparator
      Ex: min(Comparator.naturalOrder()/Comparator.reverseOrder())
   5. max(): last element after compairing all. Input is Comparator
      Ex: max(Comparator.naturalOrder()/Comparator.reverseOrder())
   6. findAny(): just give one element from the stream. No Input
      Ex: findAny()
   7. findFirst(): just give firs element from the stream. No Input
      Ex: findFirst()
   8. anyMatch(): is there any element in the stream which satisfies the condition. Input is Predicate<T>
      Ex: anyMatch(i -> i>5)
   9. noneMatch(): all elements in the stream should not satisfy the condition. Input is Predicate<T>
      Ex: noneMatch(i -> i>5)
   10. reduce(): combines all elements into one element.
      Ex: reduce((a,b) -> a+b)


-- Stream parallel: creates multiple threads which increases the performance and also reduces the execution data.
   Ex: list.stream().parallel().map().filter().forEach()

-- Streams can be created using strings as well.
   Ex: Stream.of("string","string","string")

-- Optional<String> means that if there is a chance that the operation might return null, then instead of returning null and causing null pointer exception, return an Optional<String> object. 
   Optional object can be of any type, i.e., String, WebDriver, Integer, etc  





